# Usage Examples

This document provides detailed examples of using AlgoAtlas.

## Basic Workflow

### 1. Start the CLI

```bash
python -m algo_atlas
```

Output:
```
AlgoAtlas
---------
 * Running startup checks...

 + Claude CLI installed
 + Vault configured: D:\GitHub - Personal\algo-atlas-vault
```

### 2. Enter a LeetCode URL

```
? Enter LeetCode problem URL (or 'q' to quit): https://leetcode.com/problems/two-sum/

 -> Scraping problem from LeetCode...
 + Found: 1. Two Sum (Easy)
 * Topics: Array, Hash Table
```

### 3. Provide Your Solution

You can either paste code directly or provide a file path.

**Option A: Paste code directly**
```
Enter solution code:
  - Paste a file path (e.g., solution.py)
  - Or paste code directly, then enter 'END' on a new line

class Solution:
    def twoSum(self, nums, target):
        seen = {}
        for i, n in enumerate(nums):
            if target - n in seen:
                return [seen[target - n], i]
            seen[n] = i
END

 + Code received
```

**Option B: Provide a file path**
```
Enter solution code:
  - Paste a file path (e.g., solution.py)
  - Or paste code directly, then enter 'END' on a new line

C:\Users\me\solutions\two_sum.py

 + Loaded from: C:\Users\me\solutions\two_sum.py
```

### 4. Verification

```
 -> Verifying solution...
 * Generating expected outputs for test cases...
 + Syntax valid
 + All tests passed (3/3)
```

If tests fail:
```
 -> Verifying solution...
 + Syntax valid
 ! Tests: 2/3 passed
 x   Test 3: expected [0, 1], got [1, 0]

? Continue despite verification issues? [y/N]:
```

### 5. Documentation Generation

```
 -> Generating documentation with Claude...
 + Documentation generated
```

### 6. Save to Vault

```
 -> Saving to vault...
 + Saved: D:\vault\Easy\1. Two Sum\solution.py
 + Saved: D:\vault\Easy\1. Two Sum\README.md

 + Problem saved to: D:\vault\Easy\1. Two Sum
```

If problem already exists:
```
 -> Saving to vault...
 ! Problem already exists: D:\vault\Easy\1. Two Sum

? Overwrite existing files? [y/N]:
```

## Generated Documentation Example

Here's an example of the README.md generated by Claude:

```markdown
# 1. Two Sum

**Difficulty:** Easy

**Topics:** Array, Hash Table

**LeetCode Link:** [Problem](https://leetcode.com/problems/two-sum/)

---

## Problem Statement

Given an array of integers and a target value, find two numbers that add up to the target and return their indices.

## Approach

This solution uses a **hash map** to achieve O(n) time complexity. As we iterate through the array, we store each number and its index in a dictionary. For each number, we check if its complement (target - current number) exists in the dictionary.

## Complexity Analysis

- **Time Complexity:** O(n) - Single pass through the array
- **Space Complexity:** O(n) - Hash map stores at most n elements

## Code Walkthrough

1. Initialize an empty dictionary `seen` to store numbers and their indices
2. Iterate through the array with index `i` and value `n`
3. Calculate complement as `target - n`
4. If complement exists in `seen`, return `[seen[complement], i]`
5. Otherwise, add current number to `seen` with its index

## Key Insights

- Using a hash map trades space for time, reducing from O(n²) brute force to O(n)
- We only need one pass because we check for complement before adding to map
- This handles duplicates correctly since we check before inserting
```

## Vault Structure

After processing several problems, your vault will look like:

```
algo-atlas-vault/
├── Easy/
│   ├── 1. Two Sum/
│   │   ├── solution.py
│   │   └── README.md
│   ├── 9. Palindrome Number/
│   │   ├── solution.py
│   │   └── README.md
│   └── 13. Roman to Integer/
│       ├── solution.py
│       └── README.md
├── Medium/
│   ├── 2. Add Two Numbers/
│   │   ├── solution.py
│   │   └── README.md
│   └── 3. Longest Substring Without Repeating Characters/
│       ├── solution.py
│       └── README.md
├── Hard/
│   └── 4. Median of Two Sorted Arrays/
│       ├── solution.py
│       └── README.md
└── README.md
```

## Tips

1. **Batch Processing**: You can process multiple problems in one session by selecting "Y" when asked to continue.

2. **File Input**: For longer solutions, save them to a `.py` file first and provide the path.

3. **Verification Failures**: If verification fails, you can still save - useful for problems with special output requirements.

4. **Overwriting**: The tool warns before overwriting existing solutions, so you can safely re-run for updates.
